{
  "tree": {
    "bin": {
      "gpt_context.rb": {
      }
    },
    "lib": {
      "appydave": {
        "tools": {
          "gpt_context": {
            "file_collector.rb": {
            },
            "options.rb": {
            },
            "output_handler.rb": {
            }
          }
        }
      }
    },
    "spec": {
      "appydave": {
        "tools": {
          "gpt_context": {
            "file_collector_spec.rb": {
            },
            "output_handler_spec.rb": {
            }
          }
        }
      }
    }
  },
  "content": [
    {
      "file": "bin/gpt_context.rb",
      "content": "#!/usr/bin/env ruby\n# frozen_string_literal: true\n\n# GPT Chats:\n# https://chatgpt.com/c/670df475-04f4-8002-a758-f5711bf433eb\n\n# Usage:\n#   ./bin/gpt_context.rb -d -i 'lib/openai_101/tools/**/*.rb'\n#   ./bin/gpt_context.rb -d -i 'lib/openai_101/tools/**/*' -e 'node_modules/**/*' -e 'package-lock.json' -e 'lib/openai_101/tools/prompts/*.txt'\n#\n#   Get GPT Context Gatherer code\n#   ./bin/gpt_context.rb -i 'bin/**/*gather*.rb' -i 'lib/openai_101/tools/**/*gather*.rb'\n$LOAD_PATH.unshift(File.expand_path('../lib', __dir__))\n\nrequire 'appydave/tools'\nrequire 'appydave/tools/gpt_context/options'\nrequire 'json'\nrequire 'optparse'\nrequire 'clipboard'\nrequire 'pathname'\n\noptions = Appydave::Tools::GptContext::Options.new(\n  working_directory: nil\n)\n\nOptionParser.new do |opts|\n  opts.banner = 'Usage: gather_content.rb [options]'\n\n  opts.on('-i', '--include PATTERN', 'Pattern or file to include (can be used multiple times)') do |pattern|\n    options.include_patterns << pattern\n  end\n\n  opts.on('-e', '--exclude PATTERN', 'Pattern or file to exclude (can be used multiple times)') do |pattern|\n    options.exclude_patterns << pattern\n  end\n\n  opts.on('-f', '--format FORMAT', 'Output format: content, tree, or json, if not provided then both are used') do |format|\n    options.format = format\n  end\n\n  opts.on('-l', '--line-limit LIMIT', 'Limit the number of lines included from each file') do |limit|\n    options.line_limit = limit.to_i\n  end\n\n  # New option for specifying base directory\n  opts.on('-b', '--base-dir DIRECTORY', 'Set the base directory to gather files from') do |directory|\n    options.working_directory = directory\n  end\n\n  # Debug output options\n  opts.on('-d', '--debug [MODE]', 'Enable debug mode [none, info, params, debug]', 'none', 'info', 'params', 'debug') do |debug|\n    options.debug = debug || 'info'\n  end\n\n  # Output targets: clipboard or file\n  opts.on('-o', '--output TARGET', 'Output target: clipboard, or a file path (can be used multiple times)') do |target|\n    options.output_target << target\n  end\n\n  opts.on_tail('-h', '--help', 'Show this message') do\n    puts opts\n    puts \"\\nExamples:\"\n    puts \"  #{File.basename($PROGRAM_NAME)} -i 'lib/**/*.rb' -e 'lib/excluded/**/*.rb' -d\"\n    puts \"  #{File.basename($PROGRAM_NAME)} --include 'src/**/*.js' --exclude 'src/vendor/**/*.js'\"\n\n    puts ''\n    puts '  # Get GPT Context Gatherer code that is found in any folder (bin, lib & spec)'\n    puts \"  #{File.basename($PROGRAM_NAME)} -i '**/*gather*.rb'\"\n    exit\n  end\nend.parse!\n\nif options.include_patterns.empty? && options.exclude_patterns.empty? && options.format.nil?\n  script_name = File.basename($PROGRAM_NAME, File.extname($PROGRAM_NAME))\n\n  puts 'No options provided to GPT Context. Please specify patterns to include or exclude.'\n  puts \"For help, run: #{script_name} --help\"\n  exit\nend\n\nif options.output_target.empty?\n  puts 'No output target provided. Will default to `clipboard`. You can set the output target using -o'\n  options.output_target << 'clipboard'\nend\n\npp options if options.debug == 'params'\n\noptions.working_directory ||= Dir.pwd\n\ngatherer = Appydave::Tools::GptContext::FileCollector.new(options)\ncontent = gatherer.build\n\nif %w[info debug].include?(options.debug)\n  puts '-' * 80\n  puts content\n  puts '-' * 80\nend\n\noutput_handler = Appydave::Tools::GptContext::OutputHandler.new(content, options)\noutput_handler.execute\n\npp options if options.debug == 'debug'\n"
    },
    {
      "file": "lib/appydave/tools/gpt_context/file_collector.rb",
      "content": "# frozen_string_literal: true\n\nmodule Appydave\n  module Tools\n    # Build GPT context from various sources\n    module GptContext\n      # Gathers file names and content based on include and exclude patterns\n      class FileCollector\n        def initialize(options)\n          @options = options\n          @include_patterns = options.include_patterns\n          @exclude_patterns = options.exclude_patterns\n          @format = options.format\n          @working_directory = options.working_directory\n          @line_limit = options.line_limit\n        end\n\n        def build\n          FileUtils.cd(@working_directory) if @working_directory && Dir.exist?(@working_directory)\n\n          formats = @format.split(',')\n          result = formats.map do |fmt|\n            case fmt\n            when 'tree'\n              build_tree\n            when 'content'\n              build_content\n            when 'json'\n              build_json\n            else\n              ''\n            end\n          end.join(\"\\n\\n\")\n\n          FileUtils.cd(Dir.home) if @working_directory\n\n          result\n        end\n\n        private\n\n        def build_content\n          concatenated_content = []\n\n          @include_patterns.each do |pattern|\n            Dir.glob(pattern).each do |file_path|\n              next if excluded?(file_path) || File.directory?(file_path)\n\n              content = \"# file: #{file_path}\\n\\n#{read_file_content(file_path)}\"\n              concatenated_content << content\n            end\n          end\n\n          concatenated_content.join(\"\\n\\n\")\n        end\n\n        def read_file_content(file_path)\n          lines = File.readlines(file_path)\n          return lines.first(@line_limit).join if @line_limit\n\n          lines.join\n        end\n\n        def build_tree\n          tree_view = {}\n\n          @include_patterns.each do |pattern|\n            Dir.glob(pattern).each do |file_path|\n              next if excluded?(file_path)\n\n              path_parts = file_path.split('/')\n              insert_into_tree(tree_view, path_parts)\n            end\n          end\n\n          build_tree_pretty(tree_view).rstrip\n        end\n\n        def insert_into_tree(tree, path_parts)\n          node = tree\n          path_parts.each do |part|\n            node[part] ||= {}\n            node = node[part]\n          end\n        end\n\n        def build_tree_pretty(node, prefix: '', is_last: true, output: ''.dup)\n          node.each_with_index do |(part, child), index|\n            connector = is_last && index == node.size - 1 ? '└' : '├'\n            output << \"#{prefix}#{connector}─ #{part}\\n\"\n            next_prefix = is_last && index == node.size - 1 ? '  ' : '│ '\n            build_tree_pretty(child, prefix: \"#{prefix}#{next_prefix}\", is_last: child.empty? || index == node.size - 1, output: output)\n          end\n          output\n        end\n\n        def build_json\n          json_output = {\n            'tree' => {},\n            'content' => []\n          }\n\n          # Building tree structure in JSON\n          @include_patterns.each do |pattern|\n            Dir.glob(pattern).each do |file_path|\n              next if excluded?(file_path)\n\n              path_parts = file_path.split('/')\n              insert_into_tree(json_output['tree'], path_parts)\n            end\n          end\n\n          # Building content structure in JSON\n          @include_patterns.each do |pattern|\n            Dir.glob(pattern).each do |file_path|\n              next if excluded?(file_path) || File.directory?(file_path)\n\n              json_output['content'] << {\n                'file' => file_path,\n                'content' => read_file_content(file_path)\n              }\n            end\n          end\n\n          JSON.pretty_generate(json_output)\n        end\n\n        def excluded?(file_path)\n          @exclude_patterns.any? { |pattern| File.fnmatch(pattern, file_path, File::FNM_PATHNAME | File::FNM_DOTMATCH) }\n        end\n      end\n    end\n  end\nend\n"
    },
    {
      "file": "lib/appydave/tools/gpt_context/options.rb",
      "content": "# frozen_string_literal: true\n\nmodule Appydave\n  module Tools\n    module GptContext\n      # Struct with keyword_init: true to allow named parameters\n      Options = Struct.new(\n        :include_patterns,\n        :exclude_patterns,\n        :format,\n        :line_limit,\n        :debug,\n        :output_target,\n        :working_directory,\n        keyword_init: true\n      ) do\n        def initialize(**args)\n          super\n          self.include_patterns ||= []\n          self.exclude_patterns ||= []\n          self.format ||= 'tree,content'\n          self.debug ||= 'none'\n          self.output_target ||= []\n        end\n      end\n    end\n  end\nend\n"
    },
    {
      "file": "lib/appydave/tools/gpt_context/output_handler.rb",
      "content": "# frozen_string_literal: true\n\nmodule Appydave\n  module Tools\n    module GptContext\n      class OutputHandler\n        def initialize(content, options)\n          @content = content\n          @output_targets = options.output_target\n          @working_directory = options.working_directory\n        end\n\n        def execute\n          @output_targets.each do |target|\n            case target\n            when 'clipboard'\n              Clipboard.copy(@content)\n            when /^.+$/\n              write_to_file(target)\n            end\n          end\n        end\n\n        private\n\n        attr_reader :content, :output_targets, :working_directory\n\n        def write_to_file(target)\n          resolved_path = Pathname.new(target).absolute? ? target : File.join(working_directory, target)\n          File.write(resolved_path, content)\n        end\n      end\n    end\n  end\nend\n"
    },
    {
      "file": "spec/appydave/tools/gpt_context/file_collector_spec.rb",
      "content": "# frozen_string_literal: true\n\nRSpec.describe Appydave::Tools::GptContext::FileCollector do\n  describe '#build' do\n    subject { described_class.new(include_patterns: include_patterns, exclude_patterns: exclude_patterns, format: format, line_limit: line_limit) }\n\n    let(:include_patterns) { ['spec/fixtures/gpt-content-gatherer/**/*.txt'] }\n    let(:exclude_patterns) { ['spec/fixtures/gpt-content-gatherer/excluded/*.txt', '**/deep/**/*'] }\n    let(:format) { 'content' }\n    let(:line_limit) { nil }\n\n    context 'when gathering content' do\n      it 'concatenates content from files matching include patterns' do\n        expect(subject.build).to include('File 1 content', 'File 2 content')\n      end\n\n      it 'excludes content from files matching exclude patterns' do\n        expect(subject.build).not_to include('Excluded file content')\n        expect(subject.build).not_to include('Deep 1')\n        expect(subject.build).not_to include('Deep 1')\n      end\n\n      it 'includes file paths as headers in the gathered content' do\n        expect(subject.build)\n          .to include('# file: spec/fixtures/gpt-content-gatherer/included/file1.txt')\n          .and include('# file: spec/fixtures/gpt-content-gatherer/included/file2.txt')\n      end\n    end\n\n    context 'when line limit is set' do\n      let(:line_limit) { 1 }\n\n      it 'limits the number of lines included from each file' do\n        expect(subject.build).not_to include('Line #2')\n      end\n    end\n  end\n\n  describe '#build with tree format' do\n    subject { described_class.new(include_patterns: include_patterns, exclude_patterns: exclude_patterns, format: 'tree') }\n\n    let(:include_patterns) { ['spec/fixtures/gpt-content-gatherer/**/*'] }\n    let(:exclude_patterns) { [] }\n\n    before do\n      allow(Dir).to receive(:glob).and_return(\n        [\n          'spec/fixtures/gpt-content-gatherer/included/file1.txt',\n          'spec/fixtures/gpt-content-gatherer/included/file2.txt',\n          'spec/fixtures/gpt-content-gatherer/included/subdir/file3.txt'\n        ]\n      )\n      allow(File).to receive(:directory?).and_return(false)\n    end\n\n    it 'prints a tree view of the included files and directories with improved ASCII art' do\n      expected_output = <<~TREE\n        └─ spec\n          └─ fixtures\n            └─ gpt-content-gatherer\n              └─ included\n                ├─ file1.txt\n                ├─ file2.txt\n                └─ subdir\n                  └─ file3.txt\n      TREE\n\n      expect(subject.build.strip).to eq(expected_output.strip)\n    end\n  end\n\n  describe '#build with both formats' do\n    subject { described_class.new(include_patterns: include_patterns, exclude_patterns: exclude_patterns, format: 'tree,content') }\n\n    let(:include_patterns) { ['spec/fixtures/gpt-content-gatherer/**/*'] }\n    let(:exclude_patterns) { [] }\n\n    before do\n      allow(Dir).to receive(:glob).and_return(\n        [\n          'spec/fixtures/gpt-content-gatherer/included/file1.txt',\n          'spec/fixtures/gpt-content-gatherer/included/file2.txt',\n          'spec/fixtures/gpt-content-gatherer/included/subdir/file3.txt'\n        ]\n      )\n      allow(File).to receive(:directory?).and_return(false)\n    end\n\n    it 'prints both a tree view and the file contents' do\n      expected_output_tree = <<~TREE\n        └─ spec\n          └─ fixtures\n            └─ gpt-content-gatherer\n              └─ included\n                ├─ file1.txt\n                ├─ file2.txt\n                └─ subdir\n                  └─ file3.txt\n      TREE\n\n      expected_output_content = <<~CONTENT\n        # file: spec/fixtures/gpt-content-gatherer/included/file1.txt\n\n        File 1 content\n        Line #2\n\n        # file: spec/fixtures/gpt-content-gatherer/included/file2.txt\n\n        File 2 content\n        Line #2\n\n        # file: spec/fixtures/gpt-content-gatherer/included/subdir/file3.txt\n\n        File 3 content\n        Line #2\n      CONTENT\n\n      expect(subject.build).to include(expected_output_tree.strip)\n      expect(subject.build).to include(expected_output_content.strip)\n    end\n  end\nend\n"
    },
    {
      "file": "spec/appydave/tools/gpt_context/output_handler_spec.rb",
      "content": "# frozen_string_literal: true\n\nRSpec.describe Appydave::Tools::GptContext::OutputHandler do\n  subject { described_class.new(content, options) }\n\n  let(:content) { 'Sample content' }\n  let(:options) { double('Options', output_target: ['clipboard'], working_directory: Dir.pwd) }\n\n  describe '#execute' do\n    it 'copies content to clipboard when output target is clipboard' do\n      expect(Clipboard).to receive(:copy).with(content)\n      subject.execute\n    end\n\n    context 'when output target is a file' do\n      let(:options) { double('Options', output_target: ['output.txt'], working_directory: Dir.pwd) }\n\n      it 'writes content to the specified file' do\n        expect(File).to receive(:write).with(File.join(Dir.pwd, 'output.txt'), content)\n        subject.execute\n      end\n    end\n\n    context 'when multiple output targets are specified' do\n      let(:options) { double('Options', output_target: ['clipboard', 'output.txt'], working_directory: Dir.pwd) }\n\n      it 'copies content to clipboard and writes to file' do\n        expect(Clipboard).to receive(:copy).with(content)\n        expect(File).to receive(:write).with(File.join(Dir.pwd, 'output.txt'), content)\n        subject.execute\n      end\n    end\n  end\nend\n"
    }
  ]
}