# frozen_string_literal: true

module Appydave
  module Tools
    module Jump
      module Commands
        # Generate command creates shell aliases and help content
        class Generate < Base
          VALID_TARGETS = %w[aliases help ah-help all].freeze
          MAX_BACKUPS = 10

          TITLE_MAPPINGS = {
            'appydave' => 'Appy Dave',
            'supportsignal' => 'SupportSignal',
            'beauty-and-joy' => 'Beauty & Joy',
            'david-cruwys' => 'David Cruwys',
            'guy-monroe' => 'Guy Monroe',
            'voz' => 'VOZ',
            'kiros' => 'Kiros',
            'aitldr' => 'AITLDR'
          }.freeze

          attr_reader :target, :output_path, :output_dir

          # rubocop:disable Metrics/ParameterLists
          def initialize(config, target, output_path: nil, output_dir: nil, path_validator: PathValidator.new, **options)
            super(config, path_validator: path_validator, **options)
            @target = target
            @output_path = output_path
            @output_dir = output_dir
          end
          # rubocop:enable Metrics/ParameterLists

          def run
            unless VALID_TARGETS.include?(target)
              return error_result(
                "Unknown generate target: #{target}",
                code: 'INVALID_INPUT',
                suggestion: "Valid targets: #{VALID_TARGETS.join(', ')}"
              )
            end

            # Convert hyphenated targets to underscored method names
            method_name = "generate_#{target.tr('-', '_')}"
            send(method_name)
          end

          private

          def generate_aliases
            content = build_aliases_content
            write_or_return(content, output_path, 'aliases-jump.zsh')
          end

          def generate_help
            content = build_help_content
            write_or_return(content, output_path, 'jump-help.txt')
          end

          def generate_ah_help
            content = build_ah_help_content
            write_or_return(content, output_path, 'aliases-help.zsh')
          end

          def generate_all
            aliases_content = build_aliases_content
            help_content = build_help_content

            if output_dir
              aliases_path = File.join(output_dir, 'aliases-jump.zsh')
              help_path = File.join(output_dir, 'data', 'jump-help.txt')

              FileUtils.mkdir_p(File.dirname(aliases_path))
              FileUtils.mkdir_p(File.dirname(help_path))

              File.write(aliases_path, aliases_content)
              File.write(help_path, help_content)

              success_result(
                message: 'Generated all files',
                files: [aliases_path, help_path]
              )
            else
              success_result(
                aliases: aliases_content,
                help: help_content
              )
            end
          end

          def build_aliases_content
            lines = []
            lines << '# Jump Location Aliases'
            lines << "# Generated by: jump generate aliases (#{Time.now.strftime('%Y-%m-%d %H:%M')})"
            lines << '# Source: ~/.config/appydave/locations.json'
            lines << ''

            # Build grouped sections using smart logic
            sections = build_smart_alias_sections

            sections.each do |section|
              # Add major section separator if needed
              if section[:major]
                lines << '# ========================================'
                lines << "# #{section[:title]}"
                lines << '# ========================================'
              else
                lines << "# #{section[:title]}"
              end

              section[:locations].each do |loc|
                path = format_display_path(loc.path)
                lines << "alias #{loc.jump}=\"cd #{path}\""
              end

              lines << ''
            end

            lines.join("\n")
          end

          def build_help_content
            lines = []
            lines << '# Jump Location Help'
            lines << "# Generated: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
            lines << ''

            # Format for fzf/ah integration
            config.locations.each do |loc|
              path = path_validator.expand(loc.path)
              brand_client = loc.brand || loc.client || ''
              type = loc.type || ''
              desc = loc.description || ''

              # Format: jump_alias | path | brand/client | type | description
              lines << "#{loc.jump}\t#{path}\t#{brand_client}\t#{type}\t#{desc}"
            end

            lines.join("\n")
          end

          def build_ah_help_content
            lines = []

            # Group locations into logical sections
            sections = group_locations_for_ah_help

            sections.each do |section_name, locations|
              lines << "## #{section_name}"

              locations.each do |loc|
                path = format_display_path(loc.path)
                tags = build_ah_tags(loc)

                # Format: alias (24 chars) + path + tags
                alias_col = loc.jump.ljust(24)
                path_with_tags = "#{path}#{' ' * [1, 48 - path.length].max}#{tags}"

                lines << "#{alias_col}#{path_with_tags}"
              end

              lines << ''
            end

            lines.join("\n")
          end

          def format_display_path(path)
            # Collapse home directory to ~
            expanded = path_validator.expand(path)
            home = Dir.home
            expanded.start_with?(home) ? expanded.sub(home, '~') : expanded
          end

          def build_ah_tags(loc)
            tags = [loc.type, loc.brand, loc.client].compact.reject(&:empty?)
            tags.concat(loc.tags) if loc.tags
            tags.uniq.map { |t| "##{t}" }.join(' ')
          end

          def group_locations_for_ah_help
            sections = {
              'Base Directories' => [],
              'Brand Projects - AppyDave' => [],
              'Brand Projects - Other' => [],
              'Client Projects' => [],
              'Video Projects' => [],
              'Ruby Gems' => [],
              'Reference & Archives' => [],
              'Other' => []
            }

            config.locations.each do |loc|
              section = determine_ah_section(loc)
              sections[section] << loc
            end

            # Remove empty sections and sort locations within each
            sections.reject { |_, locs| locs.empty? }.transform_values do |locs|
              locs.sort_by(&:jump)
            end
          end

          # rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity
          def determine_ah_section(loc)
            type = loc.type&.downcase
            brand = loc.brand&.downcase

            case type
            when 'monorepo', 'config'
              return 'Base Directories' if loc.client.nil? && loc.brand.nil?
            when 'video'
              return 'Video Projects'
            when 'gem'
              return 'Ruby Gems'
            when 'client'
              return 'Client Projects'
            when 'archive', 'reference'
              return 'Reference & Archives'
            end

            return 'Client Projects' if loc.client

            case brand
            when 'appydave'
              'Brand Projects - AppyDave'
            when 'beauty-and-joy', 'david-cruwys', 'aitldr'
              'Brand Projects - Other'
            else
              'Other'
            end
          end
          # rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity

          def group_locations_for_aliases
            grouped = {}

            config.locations.each do |loc|
              group = loc.brand || loc.client || 'Other'
              grouped[group] ||= []
              grouped[group] << loc
            end

            # Sort groups and locations within groups
            grouped.sort.to_h.transform_values do |locs|
              locs.sort_by(&:key)
            end
          end

          # rubocop:disable Metrics/MethodLength, Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity
          def build_smart_alias_sections
            sections = []
            locations = config.locations.dup

            # 1. JUMPS - Base directories (monorepo/config without brand/client)
            jumps = locations.select { |l| %w[monorepo config].include?(l.type) && l.brand.nil? && l.client.nil? }
            add_section(sections, 'JUMPS', jumps) unless jumps.empty?
            locations -= jumps

            # 2. Brain / Second Brain (only non-client brains)
            brains = locations.select { |l| l.type == 'brain' && l.client.nil? }
            add_section(sections, 'Brain / Second Brain', brains) unless brains.empty?
            locations -= brains

            # 3. Appy Dave (including david-cruwys ecosystem docs, excluding video, archive, and subprojects)
            appydave_all = locations.select do |l|
              %w[appydave david-cruwys].include?(l.brand) && !%w[video archive brain].include?(l.type)
            end

            # Extract subgroups
            flivideo = appydave_all.select { |l| l.key.start_with?('flivideo') }
            storyline = appydave_all.select { |l| l.key.start_with?('storyline') }
            awb = appydave_all.select { |l| l.key.start_with?('agent-workflow', 'awb') }
            klueless = appydave_all.select { |l| l.key == 'klueless' }

            appydave_main = appydave_all - flivideo - storyline - awb - klueless

            add_section(sections, 'Appy Dave', appydave_main) unless appydave_main.empty?
            add_section(sections, 'KlueLess', klueless) unless klueless.empty?
            add_section(sections, 'FliVideo', flivideo) unless flivideo.empty?
            add_section(sections, 'Storyline App', storyline) unless storyline.empty?
            add_section(sections, 'Agent Workflow Builder', awb) unless awb.empty?

            locations -= appydave_all

            # 4. CLIENT WORK (major section)
            clients = locations.select { |l| l.client && l.type != 'video' }
            unless clients.empty?
              # Add major separator
              sections << { title: 'CLIENT WORK', major: true, locations: [] }

              # Group by client
              clients.group_by(&:client).sort.each do |client_name, client_locs|
                title = format_title(client_name, 'Client')
                add_section(sections, title, client_locs)
              end
            end
            locations -= clients

            # 5. VIDEO PROJECTS (major section)
            videos = locations.select { |l| l.type == 'video' }
            unless videos.empty?
              sections << { title: 'VIDEO PROJECTS', major: true, locations: [] }

              # Split into brand and client videos
              brand_videos = videos.select(&:brand)
              client_videos = videos.select(&:client)
              other_videos = videos - brand_videos - client_videos

              add_section(sections, 'Brand Video Projects', brand_videos) unless brand_videos.empty?
              add_section(sections, 'Client Video Projects', client_videos) unless client_videos.empty?
              add_section(sections, 'Video Projects', other_videos) unless other_videos.empty?
            end
            locations -= videos

            # 6. Beauty & Joy (non-video)
            joy = locations.select { |l| l.brand == 'beauty-and-joy' }
            add_section(sections, 'Beauty & Joy', joy, major: true) unless joy.empty?
            locations -= joy

            # 7. Archive
            archives = locations.select { |l| l.type == 'archive' }
            add_section(sections, 'Archive', archives) unless archives.empty?
            locations -= archives

            # 8. GEMs
            gems = locations.select { |l| l.type == 'gem' }
            add_section(sections, 'GEMs', gems) unless gems.empty?
            locations -= gems

            # 9. Reference / 3rd Party
            refs = locations.select { |l| l.type == 'reference' }
            add_section(sections, 'Reference / 3rd Party', refs) unless refs.empty?
            locations -= refs

            # 10. Experiments
            experiments = locations.select { |l| l.type == 'experiments' }
            add_section(sections, 'Experiments', experiments) unless experiments.empty?
            locations -= experiments

            # 11. Other (anything remaining)
            add_section(sections, 'Other', locations) unless locations.empty?

            sections.reject { |s| s[:locations].empty? && !s[:major] }
          end
          # rubocop:enable Metrics/MethodLength, Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity

          def add_section(sections, title, locations, major: false)
            return if locations.empty?

            sections << {
              title: title,
              major: major,
              locations: locations.sort_by(&:jump)
            }
          end

          def format_title(name, suffix = nil)
            title = TITLE_MAPPINGS[name] || name.split('-').map(&:capitalize).join(' ')
            suffix ? "#{title} #{suffix}" : title
          end

          def write_or_return(content, path, default_filename)
            if path
              backup_result = backup_existing_file(path)
              FileUtils.mkdir_p(File.dirname(path))
              File.write(path, content)

              result = success_result(
                message: "Generated #{default_filename}",
                path: path,
                lines: content.lines.count
              )
              result[:backup] = backup_result if backup_result
              result
            else
              success_result(
                content: content,
                lines: content.lines.count
              )
            end
          end

          def backup_existing_file(path)
            return nil unless File.exist?(path)

            # Create backup directory
            dir = File.dirname(path)
            filename = File.basename(path, '.*')
            backup_dir = File.join(dir, 'backups', filename)
            FileUtils.mkdir_p(backup_dir)

            # Generate timestamped backup filename
            timestamp = Time.now.strftime('%Y-%m-%d-%H%M%S')
            ext = File.extname(path)
            backup_path = File.join(backup_dir, "#{timestamp}#{ext}")

            # Copy existing file to backup
            FileUtils.cp(path, backup_path)

            # Clean up old backups (keep last N)
            cleanup_old_backups(backup_dir, ext)

            backup_path
          end

          def cleanup_old_backups(backup_dir, ext)
            backups = Dir.glob(File.join(backup_dir, "*#{ext}")).sort.reverse
            return if backups.length <= MAX_BACKUPS

            backups[MAX_BACKUPS..].each { |f| File.delete(f) }
          end
        end
      end
    end
  end
end
