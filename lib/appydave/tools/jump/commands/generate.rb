# frozen_string_literal: true

module Appydave
  module Tools
    module Jump
      module Commands
        # Generate command creates shell aliases and help content
        class Generate < Base
          VALID_TARGETS = %w[aliases help ah-help all].freeze

          attr_reader :target, :output_path, :output_dir

          # rubocop:disable Metrics/ParameterLists
          def initialize(config, target, output_path: nil, output_dir: nil, path_validator: PathValidator.new, **options)
            super(config, path_validator: path_validator, **options)
            @target = target
            @output_path = output_path
            @output_dir = output_dir
          end
          # rubocop:enable Metrics/ParameterLists

          def run
            unless VALID_TARGETS.include?(target)
              return error_result(
                "Unknown generate target: #{target}",
                code: 'INVALID_INPUT',
                suggestion: "Valid targets: #{VALID_TARGETS.join(', ')}"
              )
            end

            # Convert hyphenated targets to underscored method names
            method_name = "generate_#{target.tr('-', '_')}"
            send(method_name)
          end

          private

          def generate_aliases
            content = build_aliases_content
            write_or_return(content, output_path, 'aliases-jump.zsh')
          end

          def generate_help
            content = build_help_content
            write_or_return(content, output_path, 'jump-help.txt')
          end

          def generate_ah_help
            content = build_ah_help_content
            write_or_return(content, output_path, 'aliases-help.zsh')
          end

          def generate_all
            aliases_content = build_aliases_content
            help_content = build_help_content

            if output_dir
              aliases_path = File.join(output_dir, 'aliases-jump.zsh')
              help_path = File.join(output_dir, 'data', 'jump-help.txt')

              FileUtils.mkdir_p(File.dirname(aliases_path))
              FileUtils.mkdir_p(File.dirname(help_path))

              File.write(aliases_path, aliases_content)
              File.write(help_path, help_content)

              success_result(
                message: 'Generated all files',
                files: [aliases_path, help_path]
              )
            else
              success_result(
                aliases: aliases_content,
                help: help_content
              )
            end
          end

          def build_aliases_content
            lines = []
            lines << '# Jump Location Aliases'
            lines << "# Generated by: jump generate aliases (#{Time.now.strftime('%Y-%m-%d %H:%M')})"
            lines << '# Source: ~/.config/appydave/locations.json'
            lines << ''
            lines << '# Usage: source this file in your .zshrc'
            lines << '#   source ~/.oh-my-zsh/custom/aliases-jump.zsh'
            lines << ''

            # Group by brand/client
            grouped = group_locations_for_aliases

            grouped.each do |group_name, locations|
              lines << "# #{group_name}"
              locations.each do |loc|
                path = path_validator.expand(loc.path)
                desc = loc.description ? "  # #{loc.description}" : ''
                lines << "alias #{loc.jump}=\"cd '#{path}'\"#{desc}"
              end
              lines << ''
            end

            lines.join("\n")
          end

          def build_help_content
            lines = []
            lines << '# Jump Location Help'
            lines << "# Generated: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
            lines << ''

            # Format for fzf/ah integration
            config.locations.each do |loc|
              path = path_validator.expand(loc.path)
              brand_client = loc.brand || loc.client || ''
              type = loc.type || ''
              desc = loc.description || ''

              # Format: jump_alias | path | brand/client | type | description
              lines << "#{loc.jump}\t#{path}\t#{brand_client}\t#{type}\t#{desc}"
            end

            lines.join("\n")
          end

          def build_ah_help_content
            lines = []

            # Group locations into logical sections
            sections = group_locations_for_ah_help

            sections.each do |section_name, locations|
              lines << "## #{section_name}"

              locations.each do |loc|
                path = format_display_path(loc.path)
                tags = build_ah_tags(loc)

                # Format: alias (24 chars) + path + tags
                alias_col = loc.jump.ljust(24)
                path_with_tags = "#{path}#{' ' * [1, 48 - path.length].max}#{tags}"

                lines << "#{alias_col}#{path_with_tags}"
              end

              lines << ''
            end

            lines.join("\n")
          end

          def format_display_path(path)
            # Collapse home directory to ~
            expanded = path_validator.expand(path)
            home = Dir.home
            expanded.start_with?(home) ? expanded.sub(home, '~') : expanded
          end

          def build_ah_tags(loc)
            tags = [loc.type, loc.brand, loc.client].compact.reject(&:empty?)
            tags.concat(loc.tags) if loc.tags
            tags.uniq.map { |t| "##{t}" }.join(' ')
          end

          def group_locations_for_ah_help
            sections = {
              'Base Directories' => [],
              'Brand Projects - AppyDave' => [],
              'Brand Projects - Other' => [],
              'Client Projects' => [],
              'Video Projects' => [],
              'Ruby Gems' => [],
              'Reference & Archives' => [],
              'Other' => []
            }

            config.locations.each do |loc|
              section = determine_ah_section(loc)
              sections[section] << loc
            end

            # Remove empty sections and sort locations within each
            sections.reject { |_, locs| locs.empty? }.transform_values do |locs|
              locs.sort_by(&:jump)
            end
          end

          # rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity
          def determine_ah_section(loc)
            type = loc.type&.downcase
            brand = loc.brand&.downcase

            case type
            when 'monorepo', 'config'
              return 'Base Directories' if loc.client.nil? && loc.brand.nil?
            when 'video'
              return 'Video Projects'
            when 'gem'
              return 'Ruby Gems'
            when 'client'
              return 'Client Projects'
            when 'archive', 'reference'
              return 'Reference & Archives'
            end

            return 'Client Projects' if loc.client

            case brand
            when 'appydave'
              'Brand Projects - AppyDave'
            when 'beauty-and-joy', 'david-cruwys', 'aitldr'
              'Brand Projects - Other'
            else
              'Other'
            end
          end
          # rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity

          def group_locations_for_aliases
            grouped = {}

            config.locations.each do |loc|
              group = loc.brand || loc.client || 'Other'
              grouped[group] ||= []
              grouped[group] << loc
            end

            # Sort groups and locations within groups
            grouped.sort.to_h.transform_values do |locs|
              locs.sort_by(&:key)
            end
          end

          def write_or_return(content, path, default_filename)
            if path
              FileUtils.mkdir_p(File.dirname(path))
              File.write(path, content)
              success_result(
                message: "Generated #{default_filename}",
                path: path,
                lines: content.lines.count
              )
            else
              success_result(
                content: content,
                lines: content.lines.count
              )
            end
          end
        end
      end
    end
  end
end
