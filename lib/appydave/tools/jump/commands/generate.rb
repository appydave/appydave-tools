# frozen_string_literal: true

module Appydave
  module Tools
    module Jump
      module Commands
        # Generate command creates shell aliases and help content
        class Generate < Base
          VALID_TARGETS = %w[aliases help all].freeze

          attr_reader :target, :output_path, :output_dir

          # rubocop:disable Metrics/ParameterLists
          def initialize(config, target, output_path: nil, output_dir: nil, path_validator: PathValidator.new, **options)
            super(config, path_validator: path_validator, **options)
            @target = target
            @output_path = output_path
            @output_dir = output_dir
          end
          # rubocop:enable Metrics/ParameterLists

          def run
            unless VALID_TARGETS.include?(target)
              return error_result(
                "Unknown generate target: #{target}",
                code: 'INVALID_INPUT',
                suggestion: "Valid targets: #{VALID_TARGETS.join(', ')}"
              )
            end

            send("generate_#{target}")
          end

          private

          def generate_aliases
            content = build_aliases_content
            write_or_return(content, output_path, 'aliases-jump.zsh')
          end

          def generate_help
            content = build_help_content
            write_or_return(content, output_path, 'jump-help.txt')
          end

          def generate_all
            aliases_content = build_aliases_content
            help_content = build_help_content

            if output_dir
              aliases_path = File.join(output_dir, 'aliases-jump.zsh')
              help_path = File.join(output_dir, 'data', 'jump-help.txt')

              FileUtils.mkdir_p(File.dirname(aliases_path))
              FileUtils.mkdir_p(File.dirname(help_path))

              File.write(aliases_path, aliases_content)
              File.write(help_path, help_content)

              success_result(
                message: 'Generated all files',
                files: [aliases_path, help_path]
              )
            else
              success_result(
                aliases: aliases_content,
                help: help_content
              )
            end
          end

          def build_aliases_content
            lines = []
            lines << '# Jump Location Aliases'
            lines << "# Generated by: jump generate aliases (#{Time.now.strftime('%Y-%m-%d %H:%M')})"
            lines << '# Source: ~/.config/appydave/locations.json'
            lines << ''
            lines << '# Usage: source this file in your .zshrc'
            lines << '#   source ~/.oh-my-zsh/custom/aliases-jump.zsh'
            lines << ''

            # Group by brand/client
            grouped = group_locations_for_aliases

            grouped.each do |group_name, locations|
              lines << "# #{group_name}"
              locations.each do |loc|
                path = path_validator.expand(loc.path)
                desc = loc.description ? "  # #{loc.description}" : ''
                lines << "alias #{loc.jump}=\"cd '#{path}'\"#{desc}"
              end
              lines << ''
            end

            lines.join("\n")
          end

          def build_help_content
            lines = []
            lines << '# Jump Location Help'
            lines << "# Generated: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
            lines << ''

            # Format for fzf/ah integration
            config.locations.each do |loc|
              path = path_validator.expand(loc.path)
              brand_client = loc.brand || loc.client || ''
              type = loc.type || ''
              desc = loc.description || ''

              # Format: jump_alias | path | brand/client | type | description
              lines << "#{loc.jump}\t#{path}\t#{brand_client}\t#{type}\t#{desc}"
            end

            lines.join("\n")
          end

          def group_locations_for_aliases
            grouped = {}

            config.locations.each do |loc|
              group = loc.brand || loc.client || 'Other'
              grouped[group] ||= []
              grouped[group] << loc
            end

            # Sort groups and locations within groups
            grouped.sort.to_h.transform_values do |locs|
              locs.sort_by(&:key)
            end
          end

          def write_or_return(content, path, default_filename)
            if path
              FileUtils.mkdir_p(File.dirname(path))
              File.write(path, content)
              success_result(
                message: "Generated #{default_filename}",
                path: path,
                lines: content.lines.count
              )
            else
              success_result(
                content: content,
                lines: content.lines.count
              )
            end
          end
        end
      end
    end
  end
end
